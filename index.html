<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Juan Serratos</title>

  <!-- SVG Favicon -->
  <link rel="icon" type="image/svg+xml" href="favicon.svg">
  <!-- Fallback for browsers that don't support SVG favicons -->
  <link rel="alternate icon" type="image/png" href="favicon.png">
  <!-- For iOS devices -->
  <link rel="apple-touch-icon" href="favicon.png">

  <!-- MathJax Configuration -->
  <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [['$','$'], ["\\(","\\)"]],
        processEscapes: true
      }
    });
  </script>
  <script type="text/javascript"
          src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>

  <style>
    /*─────────────────────────────────────────────────────────────────────────────*/
    /*  COLOR VARIABLES FOR LIGHT/DARK                                           */
    /*─────────────────────────────────────────────────────────────────────────────*/
    :root {
      --bg-color: #ffffff;
      --text-color: #000000;
      --link-color: #0066cc;
      --heading-color: #333333;
      --border-color: #dddddd;
      --toggle-bg: #f0f0f0;
      --toggle-circle: #555555;

      /* Ant colors */
      --ant-white: var(--bg-color);
      --ant-black: #1a1a1a;
      --ant-accent-1: #0066cc;
      --ant-accent-2: #ff6b6b;
      --ant-accent-3: #4ecdc4;
      --ant-trail-opacity: 0.15;
    }

    [data-theme="dark"] {
      --bg-color: #1a1a1a;
      --text-color: #f0f0f0;
      --link-color: #88bbff;
      --heading-color: #ffffff;
      --border-color: #555555;
      --toggle-bg: #555555;
      --toggle-circle: #f0f0f0;

      /* Ant colors */
      --ant-white: var(--bg-color);
      --ant-black: #e0e0e0;
      --ant-accent-1: #88bbff;
      --ant-accent-2: #ff9999;
      --ant-accent-3: #66d9d4;
      --ant-trail-opacity: 0.08;
    }

    /*─────────────────────────────────────────────────────────────────────────────*/
    /*  BASIC PAGE STYLING                                                        */
    /*─────────────────────────────────────────────────────────────────────────────*/
    body {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 1600px;
      margin: 0 auto;
      padding: 20px;
      font-size: 11px;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s ease, color 0.3s ease;
    }

    h1, h2, h3 {
      color: var(--heading-color);
    }

    h1 {
      font-size: 2.2em;
      margin-bottom: 20px;
      position: relative;
      z-index: 2;
    }

    h2 {
      font-size: 1.6em;
      margin-top: 30px;
      margin-bottom: 10px;
    }

    h3 {
      font-size: 1.3em;
      margin-top: 20px;
      margin-bottom: 10px;
    }

    main {
      display: flex;
      flex-direction: row;
      width: 100%;
      position: relative;
      z-index: 1;
    }

    .column {
      padding: 10px;
    }

    .about {
      flex: 2;
      max-width: 800px;
    }

    /*─────────────────────────────────────────────────────────────────────────────*/
    /*  ENHANCED ANT CANVAS                                                        */
    /*─────────────────────────────────────────────────────────────────────────────*/
    #antContainer {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      overflow: hidden;
      z-index: 0;
    }

    #antCanvas {
      width: 100%;
      height: 100%;
      display: block;
      border: none;
      background-color: var(--bg-color);
      opacity: 0;
      animation: fadeIn 2s ease-out forwards;
    }

    @keyframes fadeIn {
      to { opacity: 1; }
    }

    a {
      color: var(--link-color);
      text-decoration: none;
    }
    a:hover {
      text-decoration: underline;
    }

    figcaption {
      text-align: center;
      margin: 10px 0;
      font-size: 11px;
    }

    .project-details {
      margin-left: 20px;
      margin-bottom: 20px;
    }

    .project-visualizations {
      margin-top: 10px;
    }
    .project-visualizations ul {
      margin-top: 5px;
    }

    /*─────────────────────────────────────────────────────────────────────────────*/
    /*  DARK MODE TOGGLE BUTTON                                                    */
    /*─────────────────────────────────────────────────────────────────────────────*/
    .dark-mode-toggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      border-radius: 50%;
      background-color: var(--toggle-bg);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
      transition: background-color 0.3s ease;
      z-index: 10;
    }

    .moon-icon, .sun-icon {
      width: 20px;
      height: 20px;
      position: absolute;
      transition: opacity 0.3s ease, transform 0.3s ease;
    }
    .moon-icon { opacity: 0; }
    .sun-icon { opacity: 1; }

    [data-theme="dark"] .moon-icon { opacity: 1; }
    [data-theme="dark"] .sun-icon { opacity: 0; }

    @media (max-width: 768px) {
      main {
        flex-direction: column;
      }
      .dark-mode-toggle {
        bottom: 10px;
        left: 10px;
      }
    }
  </style>
</head>

<body>
  <h1>Juan Serratos</h1>

  <div class="dark-mode-toggle" id="darkModeToggle">
    <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
         fill="none" stroke="currentColor" stroke-width="2">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1"  x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"
         fill="none" stroke="currentColor" stroke-width="2">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </div>

  <main>
    <div class="column about">
      <h2>About</h2>
      <p>
        I am a first‐year graduate student in mathematics at the University of Pennsylvania.
        Last summer I was supported as a research fellow at MIT's CSAIL as part of SGI.
        I completed my undergraduate studies at the University of Southern California (USC)
        in the Spring of 2024. Broadly speaking, I'm interested in the subject of
        $\mathbf{Q}$‐points and the interplay between different areas of mathematics
        with the subject. My research interests fit under the umbrella term of arithmetic geometry.
        The interplay that I've indulged most of my time on is $\mathbf{Q}$‐points and algebraic geometry,
        but I'm learning more, and becoming more interested, by the Galois theory aspect relating to
        $\pi_1^{\text{ét}}$.
      </p>
      <ul>
        <li><a href="cv.pdf">CV</a></li>
      </ul>

      <h2>Research papers</h2>
      <ul>
        <li>
          <a href="https://arxiv.org/abs/2304.03523">
            On the prime spectrum of the $p$‐adic integer polynomial ring with a depiction
          </a>
        </li>
      </ul>

      <h2>Projects</h2>
      <ul>
        <li>
          <a href="projects/projects/portfolio-optimization.html">
            Hierarchical Reinforcement Learning System for Multi‐Asset Portfolio Optimization
          </a>
        </li>
        <li>
          <a href="https://summergeometry.org/sgi2024/reduced-deformation-collision-detection/">
            Reduced deformation collision detection, MIT CSAIL
          </a>
        </li>
      </ul>

      <h2>Papers</h2>
      <p>Additional papers will be posted soon.</p>

      <h2>Notes</h2>
      <p>Notes are temporarily unavailable.</p>

      <h2>Contact</h2>
      <p>My email is <a href="mailto:serratos@upenn.edu"><u>serratos@upenn.edu</u></a>.</p>
    </div>
  </main>

  <div id="antContainer">
    <canvas id="antCanvas"></canvas>
  </div>

  <script>
    //─────────────────────────────────────────────────────────────────────────────
    //  DARK MODE TOGGLE
    //─────────────────────────────────────────────────────────────────────────────
    const darkModeToggle = document.getElementById('darkModeToggle');
    const htmlElement    = document.documentElement;
    const canvas         = document.getElementById('antCanvas');
    const ctx            = canvas.getContext('2d');

    // If user previously chose a theme, use it; otherwise pick system preference:
    const savedTheme = localStorage.getItem('theme');
    if (savedTheme) {
      htmlElement.setAttribute('data-theme', savedTheme);
    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
      htmlElement.setAttribute('data-theme', 'dark');
    }

    darkModeToggle.addEventListener('click', () => {
      const currentTheme = htmlElement.getAttribute('data-theme');
      const newTheme = (currentTheme === 'light') ? 'dark' : 'light';
      htmlElement.setAttribute('data-theme', newTheme);
      localStorage.setItem('theme', newTheme);

      updateColors();
      fadeTransition();

      // Rerender any MathJax if present
      if (window.MathJax && MathJax.Hub) {
        MathJax.Hub.Queue(["Rerender", MathJax.Hub]);
      }
    });

    //─────────────────────────────────────────────────────────────────────────────
    //  ENHANCED LANGTON'S ANT SETUP
    //─────────────────────────────────────────────────────────────────────────────
    
    // Responsive canvas sizing
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    const cellSize = 2; // Smaller cells for higher resolution
    let cols = Math.floor(canvas.width / cellSize);
    let rows = Math.floor(canvas.height / cellSize);

    // Grid stores visit count and age for each cell
    let grid = Array.from({ length: rows }, () => 
      Array.from({ length: cols }, () => ({ state: 0, age: 0, visits: 0 }))
    );

    // Trail system for smooth fading
    const trailCanvas = document.createElement('canvas');
    const trailCtx = trailCanvas.getContext('2d');
    trailCanvas.width = canvas.width;
    trailCanvas.height = canvas.height;

    let colors = {
      white: '#ffffff',
      black: '#1a1a1a',
      accent1: '#0066cc',
      accent2: '#ff6b6b',
      accent3: '#4ecdc4',
      trailOpacity: 0.15
    };

    function updateColors() {
      const styles = getComputedStyle(document.documentElement);
      colors.white = styles.getPropertyValue('--bg-color').trim();
      colors.black = styles.getPropertyValue('--ant-black').trim();
      colors.accent1 = styles.getPropertyValue('--ant-accent-1').trim();
      colors.accent2 = styles.getPropertyValue('--ant-accent-2').trim();
      colors.accent3 = styles.getPropertyValue('--ant-accent-3').trim();
      colors.trailOpacity = parseFloat(styles.getPropertyValue('--ant-trail-opacity').trim());
    }

    function fadeTransition() {
      canvas.style.opacity = '0.3';
      setTimeout(() => {
        canvas.style.transition = 'opacity 0.5s ease-out';
        canvas.style.opacity = '1';
      }, 100);
    }

    // Define text content areas to avoid (in viewport coordinates)
    function getTextAreas() {
      const mainContent = document.querySelector('.about');
      const rect = mainContent.getBoundingClientRect();
      
      // Add smaller padding around text areas - just avoid spawning right on text
      const padding = 50; // pixels to stay away from text
      
      return {
        left: rect.left - padding,
        right: rect.right + padding,
        top: rect.top - padding,
        bottom: rect.bottom + padding
      };
    }

    // Check if a position is too close to text area
    function isTooCloseToText(x, y) {
      const textAreas = getTextAreas();
      const pixelX = x * cellSize;
      const pixelY = y * cellSize;
      
      return pixelX >= textAreas.left && 
             pixelX <= textAreas.right && 
             pixelY >= textAreas.top && 
             pixelY <= textAreas.bottom;
    }

    // Generate spawn position with various strategies
    function generateSpawnPosition(preferredZone) {
      let x, y;
      let attempts = 0;
      const maxAttempts = 50;
      
      do {
        switch(preferredZone) {
          case 'center-scattered':
            // Scattered around center but not too close to text
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * Math.min(cols, rows) * 0.3;
            x = Math.floor(cols/2 + Math.cos(angle) * radius);
            y = Math.floor(rows/2 + Math.sin(angle) * radius);
            break;
          case 'mid-zones':
            // Middle areas between center and edges
            if (Math.random() < 0.5) {
              x = Math.floor(cols * (0.2 + Math.random() * 0.6));
              y = Math.random() < 0.5 ? Math.floor(rows * 0.2) : Math.floor(rows * 0.8);
            } else {
              x = Math.random() < 0.5 ? Math.floor(cols * 0.2) : Math.floor(cols * 0.8);
              y = Math.floor(rows * (0.2 + Math.random() * 0.6));
            }
            break;
          case 'random-all':
            // Truly random across entire canvas
            x = Math.floor(Math.random() * cols);
            y = Math.floor(Math.random() * rows);
            break;
          case 'edges':
            // Near edges but not corners
            if (Math.random() < 0.5) {
              x = Math.random() < 0.5 ? Math.floor(Math.random() * cols * 0.1) : Math.floor(cols * 0.9 + Math.random() * cols * 0.1);
              y = Math.floor(rows * 0.1 + Math.random() * rows * 0.8);
            } else {
              x = Math.floor(cols * 0.1 + Math.random() * cols * 0.8);
              y = Math.random() < 0.5 ? Math.floor(Math.random() * rows * 0.1) : Math.floor(rows * 0.9 + Math.random() * rows * 0.1);
            }
            break;
          case 'corners':
            // Corner regions
            const corner = Math.floor(Math.random() * 4);
            const spread = 0.15;
            switch(corner) {
              case 0: // top-left
                x = Math.floor(Math.random() * cols * spread);
                y = Math.floor(Math.random() * rows * spread);
                break;
              case 1: // top-right
                x = Math.floor(cols * (1 - spread) + Math.random() * cols * spread);
                y = Math.floor(Math.random() * rows * spread);
                break;
              case 2: // bottom-left
                x = Math.floor(Math.random() * cols * spread);
                y = Math.floor(rows * (1 - spread) + Math.random() * rows * spread);
                break;
              case 3: // bottom-right
                x = Math.floor(cols * (1 - spread) + Math.random() * cols * spread);
                y = Math.floor(rows * (1 - spread) + Math.random() * rows * spread);
                break;
            }
            break;
          default:
            // Default to random
            x = Math.floor(Math.random() * cols);
            y = Math.floor(Math.random() * rows);
        }
        
        attempts++;
      } while (isTooCloseToText(x, y) && attempts < maxAttempts);
      
      return { x, y };
    }

    // Enhanced ant class with different rule sets
    class Ant {
      constructor(x, y, ruleSet = 0) {
        this.x = x;
        this.y = y;
        this.dir = Math.floor(Math.random() * 4);
        this.ruleSet = ruleSet;
        this.color = [colors.accent1, colors.accent2, colors.accent3][ruleSet % 3];
        this.speed = 1 + Math.random() * 0.5;
        this.age = 0;
        this.trail = [];
        this.maxTrailLength = 20;
      }

      step() {
        const cell = grid[this.y][this.x];
        
        // Different rules for different ants
        if (this.ruleSet === 0) {
          // Classic Langton's Ant
          cell.state = cell.state ^ 1;
          this.dir = (this.dir + (cell.state === 0 ? 1 : 3)) % 4;
        } else if (this.ruleSet === 1) {
          // Modified rule: RRLR
          cell.state = (cell.state + 1) % 4;
          const turns = [1, 1, 3, 1];
          this.dir = (this.dir + turns[cell.state]) % 4;
        } else {
          // Chaotic rule
          cell.state = cell.state ^ 1;
          this.dir = (this.dir + (cell.visits % 2 === 0 ? 1 : 2)) % 4;
        }

        cell.visits++;
        cell.age = 0;
        
        // Update trail
        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > this.maxTrailLength) {
          this.trail.shift();
        }

        // Move ant
        if (this.dir === 0) this.y = (this.y - 1 + rows) % rows;
        else if (this.dir === 1) this.x = (this.x + 1) % cols;
        else if (this.dir === 2) this.y = (this.y + 1) % rows;
        else this.x = (this.x - 1 + cols) % cols;

        this.age++;
      }

      draw() {
        // Draw trail with gradient
        this.trail.forEach((pos, i) => {
          const alpha = (i / this.trail.length) * colors.trailOpacity;
          ctx.fillStyle = this.color + Math.floor(alpha * 255).toString(16).padStart(2, '0');
          ctx.fillRect(pos.x * cellSize, pos.y * cellSize, cellSize, cellSize);
        });

        // Draw ant head with glow
        const gradient = ctx.createRadialGradient(
          this.x * cellSize + cellSize/2, 
          this.y * cellSize + cellSize/2, 
          0,
          this.x * cellSize + cellSize/2, 
          this.y * cellSize + cellSize/2, 
          cellSize * 3
        );
        gradient.addColorStop(0, this.color);
        gradient.addColorStop(1, this.color + '00');
        ctx.fillStyle = gradient;
        ctx.fillRect(
          this.x * cellSize - cellSize * 2, 
          this.y * cellSize - cellSize * 2, 
          cellSize * 5, 
          cellSize * 5
        );
      }
    }

    // Create ants with different behaviors, distributed across the canvas
    const ants = [];
    
    // Classic ants - scattered around center area
    for (let i = 0; i < 15; i++) {
      const pos = generateSpawnPosition('center-scattered');
      ants.push(new Ant(pos.x, pos.y, 0));
    }
    
    // Classic ants - mid zones between center and edges
    for (let i = 0; i < 10; i++) {
      const pos = generateSpawnPosition('mid-zones');
      ants.push(new Ant(pos.x, pos.y, 0));
    }
    
    // Modified rule ants - random distribution
    for (let i = 0; i < 12; i++) {
      const pos = generateSpawnPosition('random-all');
      ants.push(new Ant(pos.x, pos.y, 1));
    }
    
    // Chaotic ants - edges and corners for contrast
    for (let i = 0; i < 5; i++) {
      const pos = generateSpawnPosition('edges');
      ants.push(new Ant(pos.x, pos.y, 2));
    }
    
    for (let i = 0; i < 3; i++) {
      const pos = generateSpawnPosition('corners');
      ants.push(new Ant(pos.x, pos.y, 2));
    }

    updateColors();

    // Main animation loop
    let frame = 0;
    function animate() {
      // Clear with slight fade for trail effect
      ctx.fillStyle = colors.white + '08';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Age cells and draw grid
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = grid[y][x];
          cell.age++;

          if (cell.state !== 0) {
            // Calculate color based on visits and age
            const intensity = Math.min(1, cell.visits / 10);
            const fade = Math.max(0, 1 - cell.age / 1000);
            
            if (cell.visits > 5) {
              // Frequently visited cells get accent colors
              const colorIndex = cell.visits % 3;
              const accentColor = [colors.accent1, colors.accent2, colors.accent3][colorIndex];
              ctx.fillStyle = accentColor + Math.floor(fade * intensity * 255).toString(16).padStart(2, '0');
            } else {
              // Regular cells
              ctx.fillStyle = colors.black + Math.floor(fade * 255).toString(16).padStart(2, '0');
            }
            
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
          }
        }
      }

      // Step and draw ants
      const stepsPerFrame = Math.floor(8 + Math.sin(frame * 0.01) * 3);
      for (let i = 0; i < stepsPerFrame; i++) {
        ants.forEach(ant => ant.step());
      }
      
      ants.forEach(ant => ant.draw());

      frame++;
      requestAnimationFrame(animate);
    }

    // Handle resize
    window.addEventListener('resize', () => {
      resizeCanvas();
      cols = Math.floor(canvas.width / cellSize);
      rows = Math.floor(canvas.height / cellSize);
      
      // Rebuild grid
      const newGrid = Array.from({ length: rows }, () => 
        Array.from({ length: cols }, () => ({ state: 0, age: 0, visits: 0 }))
      );
      
      // Copy old data where possible
      for (let y = 0; y < Math.min(rows, grid.length); y++) {
        for (let x = 0; x < Math.min(cols, grid[0].length); x++) {
          newGrid[y][x] = grid[y][x];
        }
      }
      
      grid = newGrid;
      
      // Update trail canvas
      trailCanvas.width = canvas.width;
      trailCanvas.height = canvas.height;
    });

    animate();
  </script>
</body>
</html>